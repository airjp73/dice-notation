import {
  Token,
  DiceRollResult,
  TokenType,
  ResultToken,
  DiceRollToken,
  RolledDiceToken,
} from './tokens';
import ExhaustiveCaseError from './ExhaustiveCaseError';
import { getPrecedence, Operator } from './operators';

const rollDiceToken = (token: DiceRollToken): RolledDiceToken => {
  const rolls: number[] = [];
  for (let i = 0; i < token.count; i++) {
    rolls.push(Math.floor(Math.random() * Math.floor(token.numSides)));
  }
  return { ...token, rolls };
};

/**
 * Takes a list of Tokens from the tokenize function and processes them.
 * @param tokens the list of tokens generated by the tokenize function
 */
function processTokens(tokens: Token[]): DiceRollResult {
  const processingTokens: ResultToken[] = tokens.map(token => {
    if (token.type === TokenType.DiceRoll) {
      return rollDiceToken(token);
    } else {
      return { ...token };
    }
  });
  return process(processingTokens);
}

function doMath(val1: number, operator: Operator, val2: number): number {
  switch (operator) {
    case '*':
      return val1 * val2;
    case '+':
      return val1 + val2;
    case '-':
      return val1 - val2;
    case '/':
      return val1 / val2;
  }
}

function process(tokens: ResultToken[]): DiceRollResult {
  let currentStack: ResultToken[] = [];
  const stackStack: ResultToken[][] = [];
  let total: number = 0;

  const peekTop = () => currentStack[currentStack.length - 1];

  const popValue = (): number => {
    const top = currentStack.pop();
    if (!top) throw new Error('Expected constant or dice roll but got nothing');

    if (top.type === TokenType.Constant) {
      return top.value;
    } else if (top.type === TokenType.DiceRoll) {
      return top.rolls.reduce((agg, num) => agg + num, 0);
    } else {
      throw new Error(`Unexpected token: ${top.content}`);
    }
  };

  const popOperator = (): Operator => {
    const top = currentStack.pop();
    if (!top) throw new Error('Expected operator but got nothing');

    if (top.type !== TokenType.Operator)
      throw new Error(`Unexpected token: ${top.content}`);

    return top.operator;
  };

  const popStack = () => {
    if (currentStack.length) {
      let total = popValue();

      while (currentStack.length) {
        const operator = popOperator();
        const value = popValue();
        total = doMath(value, operator, total);
      }
    }

    const nextStack = stackStack.pop();
    if (!nextStack) throw new Error('Unexpected termination of expression');
    currentStack = nextStack;
  };

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    switch (token.type) {
      case TokenType.DiceRoll:
      case TokenType.Constant:
        const top = peekTop();
        if (top?.type === TokenType.Operator) {
          currentStack.push(token);

          const lookAhead = tokens[i + 1];
          if (
            lookAhead?.type !== TokenType.Operator ||
            getPrecedence(top.operator) <= getPrecedence(lookAhead.operator)
          ) {
            popStack();
          }
        }
        break;
      case TokenType.CloseParen:
        if (currentStack.length)
          throw new Error(`Unexpected token: ${peekTop().content}`);
        popStack();
        break;
      case TokenType.OpenParen:
        stackStack.push(currentStack);
        currentStack = [];
        break;
      case TokenType.Operator:
        currentStack.push(token);
        break;
      default:
        throw new ExhaustiveCaseError('Unknown token type', token);
    }
  }

  return;
}

export default processTokens;
