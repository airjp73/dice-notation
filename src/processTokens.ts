import {
  Token,
  DiceRollResult,
  TokenType,
  ResultToken,
  DiceRollToken,
  RolledDiceToken,
} from './tokens';
import ExhaustiveCaseError from './ExhaustiveCaseError';
import { getPrecedence } from './operators';

const rollDiceToken = (token: DiceRollToken): RolledDiceToken => {
  const rolls: number[] = [];
  for (let i = 0; i < token.count; i++) {
    rolls.push(Math.floor(Math.random() * Math.floor(token.numSides)));
  }
  return { ...token, rolls };
};

/**
 * Takes a list of Tokens from the tokenize function and processes them.
 * @param tokens the list of tokens generated by the tokenize function
 */
function processTokens(tokens: Token[]): DiceRollResult {
  const processingTokens: ResultToken[] = tokens.map(token => {
    if (token.type === TokenType.DiceRoll) {
      return rollDiceToken(token);
    } else {
      return { ...token };
    }
  });
  return process(0, processingTokens);
}

function process(currentValue: number, tokens: ResultToken[]): DiceRollResult {
  let currentStack: ResultToken[] = [];
  const stackStack: ResultToken[][] = [];

  const peekTop = () => currentStack[currentStack.length - 1];

  const popStack = () => {};

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    switch (token.type) {
      case TokenType.DiceRoll:
      case TokenType.Constant:
        const top = peekTop();
        if (top?.type === TokenType.Operator) {
          currentStack.push(token);

          const lookAhead = tokens[i + 1];
          if (
            lookAhead?.type !== TokenType.Operator ||
            getPrecedence(top.operator) <= getPrecedence(lookAhead.operator)
          ) {
            popStack();
          }
        }
        break;
      case TokenType.CloseParen:
        if (currentStack.length)
          throw new Error(`Unexpected token: ${peekTop().content}`);
        const nextStack = stackStack.pop();
        if (!nextStack) throw new Error(`Unexpected token: ${token.content}`);
        currentStack = nextStack;
        break;
      case TokenType.OpenParen:
        stackStack.push(currentStack);
        currentStack = [];
        break;
      case TokenType.Operator:
        currentStack.push(token);
        break;
      default:
        throw new ExhaustiveCaseError('Unknown token type', token);
    }
  }
}

export default processTokens;
